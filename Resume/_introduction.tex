%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
%  INTRODUCTION -----------------------------------
%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

L'optimisation combinatoire a plusieurs applications dans diff\'erents domaines tels que l'apprentissage de la machine, l'intelligence artificielle, et le g\'enie du logiciel. Dans certains cas, le but principal est seulement de trouver une solution, comme pour les Probl\`emes de Satisfaction de Contraintes (CSP). Une solution sera une affectation de variables r\'epondant aux contraintes fix\'ees, en d'autres termes: une solution faisable.

Plus formellement, un CSP (d\'enot\'e par $\mathcal{P}$) est d\'efini par le trio $\langle X,D,C \rangle$  o\`u $X = \{x_1, x_2,\dots,x_n\}$ est un ensemble fini de variables; $D = \{D_1, D_2,\dots, D_n\}$, est l'ensemble des domaines associ\'es \`a chaque variable dans $X$; et $C = \{c_1, c_2,\dots,c_m\}$, est un ensemble de contraintes. Chaque contrainte est d\'efinie en impliquant un ensemble de variables, et sp\'ecifie les combinaisons possibles de valeurs de ces variables. Une configuration $s\in D_1\times D_2\times\dots\times D_n$, est une combinaison de valeurs des variables dans $X$. Nous disons que $s$ est une solution de $\mathcal{P}$ si et seulement si $s$ satisfait toutes les contraintes $c_i \in C$.

Les {\it CSP}s sont connus pour \^etre des probl\`emes extr\^emement difficiles. Parfois les m\'ethodes compl\`etes ne sont pas capables de passer \`a l'\'echelle de probl\`emes de taille industriel. C'est la raison  pour laquelle les techniques m\'eta--heuristiques sont de plus en plus utilis\'ees pour la r\'esolution de ces derniers. Par contre, dans la plupart des cas industriels, l'espace de recherche est assez important et devient donc intraitable, m\^eme pour les m\'ethodes m\'eta-heuristiques. Cependant, les r\'ecents progr\`es dans l'architecture de l'ordinateur nous conduisent vers les ordinateurs {\it multi/many--c\oe ur}, en proposant une nouvelle fa\c{c}on de trouver des solutions \`a ces probl\`emes d'une mani\`ere plus r\'ealiste, ce qui r\'eduit le temps de recherche.

Gr\^ace \`a ces d\'eveloppements, les algorithmes parall\`eles ont ouvert de nouvelles fa\c{c}ons de r\'esoudre les probl\`emes de contraintes: Adaptive Search \cite{Diaz} est un algorithme efficace, montrant de tr\`es bonnes performances et passant \`a l'\'echelle de plusieurs centaines ou m\^eme milliers de c\oe urs, en utilisant la recherche locale {\it multi-walk} en parall\`ele. Munera et al. \cite{Munera} ont pr\'esent\'e une autre impl\'ementation d'Adaptive Search en utilisant la coop\'eration entre des strat\'egies de recherche. {\it Meta--S} est une impl\'ementation d'un cadre th\'eorique pr\'esent\'e dans \cite{Frank2003}, qui permet d'attaquer les probl\`emes par la coop\'eration de solveurs de contraintes de domaine sp\'ecifique. 
Ces travaux ont montr\'e l'efficacit\'e du sch\'ema parall\`ele multi-walk.  

De plus, le temps de d\'eveloppement n\'ecessaire pour coder des solveurs en parall\`ele est souvent sous-estim\'e, et dessiner des algorithmes efficaces pour r\'esoudre certains probl\`emes consomment trop de temps. Dans cette th\`ese nous pr\'esentons \posl{}, un langage orient\'e parall\`ele pour construire des solveurs de contraintes bas\'es sur des m\'eta-heuristiques, qui r\'esolvent des {\it CSP}s. Il fournit un m\'ecanisme pour coder des strat\'egies de communication ind\'ependantes du Le but de cet article est de proposer des nouveaux op\'erateurs de communication, tr\`es utiles pour dessiner des strat\'egies de communication, et de pr\'esenter une analyse d\'etaill\'ee des r\'esultats obtenus en r\'esolvant plusieurs instances des probl\`emes CSP. Sachant que cr\'eer des solveurs utilisant diff\'erentes strat\'egies de solution peut \^etre compliqu\'e et p\'enible, \posl{} donne la possibilit\'e de faire des prototypes de solveurs communicants facilement.  

\section {Des travaux reli\'es}

Beaucoup de chercheurs se concentrent sur la programmation par contraintes, particuli\`erement dans le d\'eveloppement de solution \`a haut-niveau qui facilitent la construction de strat\'egies de recherche. Cela permet de citer plusieurs contributions. 

{\sc Hyperion} \cite{Brownlee2014} est un syst\`eme cod\'e en Java pour m\'eta et hyper-heuristiques bas\'e sur le principe d'interop\'erabilit\'e, fournissant des patrons g\'en\'eriques pour une vari\'et\'e d'algorithmes de recherche locale et \'evolutionnaire, et permettant des prototypages rapides avec la possibilit\'e de r\'eutiliser le code source. \posl{} offre ces avantages, mais il fournit \'egalement un m\'ecanisme permettant de d\'efinir des protocoles de communication entre solveurs. Il fournit aussi, \`a travers d'un simple langage bas\'e sur des op\'erateurs, un moyen de construire des \ass, en combinant des \ms{} d\'ej\`a d\'efinis (\oms{} et \opchs). Une id\'ee similaire a \'et\'e propos\'ee dans \cite{Fukunaga2008} sans communication, qui introduit une approche \'evolutive en utilisant une simple composition d'op\'erateurs pour d\'ecouvrir automatiquement les nouvelles heuristiques de recherche locale pour SAT et les visualiser comme des combinaisons d'un ensemble de blocs.

R\'ecemment, \cite{El-Ghazali2013} a montr\'e l'efficacit\'e de combiner diff\'erentes techniques pour r\'esoudre un probl\`eme donn\'e (hybridation). Pour cette raison, lorsque les composant du solveurs peuvent \^etre combin\'es, \posl{} est dessin\'e pour ex\'ecuter en parall\`ele des ensembles de solveurs diff\'erents, avec ou sans communication. Une autre id\'ee int\'eressante est propos\'ee dans {\sc Templar}. Il s'agit d'un syst\`eme qui g\'en\`ere des algorithmes en changeant des composants pr\'ed\'efinis, et en utilisant des m\'ethodes hyper-heuristiques \cite{Swan2015}. Dans la derni\`ere phase du processus de codage avec \posl{}, les solveurs peuvent \^etre connect\'es les uns aux autres, en fonction de la structure de leurs \opchs, et de cette fa\c{c}on, ils peuvent partager non seulement des informations, mais aussi leur comportement, en partageant leurs \oms. Cette approche donne aux solveurs la capacit\'e d'\'evoluer au cours de l'ex\'ecution.

Renaud De Landtsheer et al. pr\'esentent dans \cite{Landtsheer2015} un cadre facilitant le d\'eveloppement des syst\`emes de recherches en utilisant des \textit{combinators} pour dessiner les caract\'eristiques trouv\'ees tr\`es souvent dans les proc\'edures de recherches comme des briques, et les assembler. Dans \cite{Martin2016} est propos\'ee une approche qui utilise des syst\`emes coop\'eratifs de recherche locale bas\'ee sur des m\'eta-heuristiques. Celle-ci se sert de protocoles de transfert de messages. \posl{} combine ces deux id\'ees pour assembler des composants de recherche locale \`a travers des op\'erateurs fournis (ou en cr\'eant des nouveaux), mais il fournit aussi un m\'ecanisme bas\'e sur op\'erateurs pour connecter et combiner des solveurs, en cr\'eant des strat\'egies de communication.

Dans cette th\`ese, nous pr\'esentons quelques nouveaux op\'erateurs de communication afin de concevoir des strat\'egies de communication. Avant de clore cet article par une br\`eve conclusion et de travaux futurs, nous pr\'esentons quelques r\'esultats obtenus en utilisant \posl{} pour r\'esoudre certaines instances des probl\`emes {\it Social Golfers}, {\it Costas Array}, \textit{N-Queens} et \textit{Golomb Ruler}.