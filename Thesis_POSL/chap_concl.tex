\chapter{Conclusion and future works}
\label{chap:conclusion}
\textit{In this chapter, the conclusions of this thesis is presented, emphasizing on our contribution and results. Future directions to follow are also discussed.}
\vfill
\minitoc
\newpage

\section{Conclusions}
\label{sec:conclusion_conclusion}

The era of parallel computing has opened new and more efficient ways to solve constrained problems. This development is leading us to the multi/many--core technology and massive parallel architectures, which are nowadays more accessible for a broad public through hardware like the Xeon Phi or GPU cards. For that reason, this new architecture implies new ways for designing and implementing algorithms to exploit its full potential.

The main contribution of this thesis is a Parallel-Oriented Solver Language (\posl) to solve \CSPs. These problems may have huge search spaces, making them intractable for tree-search techniques. \posl{} proposes a language to build meta-heuristic-based abstract solvers working in parallel, which can be instantiated afterwards with different \bothmodules. This feature allows the creation of many different concrete solvers through a simple and modular mechanism of code-reusing. These \ms{} are designed for the resolution of a broad range of \csps. \posl{} also provides an operator-base language to create \commstrs{} by connecting solvers to each others. The language was formally presented in Chapter~\ref{chap:posl} by defining each provided operator, as well as the benchmark codification method, and the process of creation/usage of the \bothmodules.

%Meta-heuristic methods have some times a lot of parameters to be adjusted. Prior to the \posl{}'s design, Appendix~\ref{chap:prior_paramils} contains a study in which the tool {\sc ParamILS} was used to tune {\it Adaptive Search} to solve \carr{} and {\it All-Interval Series} problems. The main goals of that work was to study the performance of the tool, and to find a new and more efficient parameters setting allowing faster resolution of the mentioned benchmark problems. However, after a comparison between results obtained using default parameters found through manual experiments, and results obtained using {\sc ParamILS}, the conclusion was that, for this implementation of Adaptive Search, the tool is not suited to find parameter settings improving results using default parameters. This corroborates the practical intuition that, when the parameters set is not so large, the experience of the scientist is crucial and more accurate than using parameter tunning tools.

%The most important characteristic of \posl{} is to allow the construction of many solvers to work in parallel using the \textit{multi-walk} approach. This has shown very good results solving constrained problems. Into another work prior to \posl's design, we have presented a study of some techniques to improve the performance of the algorithms proposed in \cite{Arbelaez2012} (\ie a study of the impact of space-partitioning techniques on the performance of parallel local search algorithms to tackle the \textit{K-Medoids Clustering Problem}). The basic idea of their specific problem is how to allocate communication metronodes in order to maximize the client covering. Their solution is based on domain partitioning techniques like {\it space-filling curves}, and {\it k-Means} algorithm, but they do not take into account the number of clients associated to each new sub-domain. For that reason, we proposed in Appendix~\ref{chap:prior_split} a set of ideas/hypothesis to improve the performance, using geometrical balancing of the search space. This work was not finished, because it was performed in parallel with the first ideas of \posl, which finally was the main direction of this thesis.

The main goal of \posl{} is to allow fast implementation of many different solvers through a mechanism of module re-usability, as well as communication strategies through communication operators. Hence, a detailed study of various communication strategies to analyze the behavior and relevance of the information sharing in solving constraint problems was presented in Chapter~\ref{chap:expe}.

A simple \commstr{} consists in sharing a ``good'' configuration (a configuration that we assume can generate new promising neighborhoods) between solvers (senders and receivers). This strategy was tested with \sgp{} (\SGP) and it was able to improve the non-cooperative results, but not significantly. In contrast to \SGP, \posl{} does not get trapped so often into local minima during the resolution of \nqp{} (\NQP{}). For that reason, using this strategy, shared information does not improve significantly the current cost when it is received and accepted by the receivers solvers, so it does not provide any gain. However, applied to \carrp{} (\CARRP) this \commstr{} improves largely the performance obtained without communication, when the communication takes place while applying the acceptance criteria.

For the resolution of \CARRP{}, the built \as{} performs several resets per iterations. For that reason, the simple \commstr{} was also tested while applying the reset, but with not good results. The reason is that the communication interferes with the proper performance of this important step in the algorithm.

Another \commstr{} in which solvers with different characteristics exchange information was tested. This strategy uses \textit{companion} solvers (solvers which produce limited by very promising neighborhoods, but in most of the cases unable to find a solution by themselves) to generate low-cost configurations in a very short amount of time and communicate them to standard solvers. This \commstr{} produces better and more robust results for both \SGP{} and \NQP{}.
% \SGP{} but not enough when it was applied to \NQP{}. However, it was implemented in both senses (\ie the communication takes places from standard solver to companion solver also) showing good results for small instances of \NQP.}

Due to the structure of the configuration in the \SGP's model, we tested a circular \commstr{} based on the sub-division of the work by weeks (\ie solvers trying to improve a configuration only working with one week). However, this strategy is not appropriate for this kind of problems, since most of the times solvers were trapped ``waiting'' for a configuration coming from its neighbor solver.

Finally, a new \commstr{} in which the communicated information is a potential local minimum to be avoided have been tested. This strategy is has been designed for problems where \posl{} performs many restarts before finding the solution. For that reason it was tested with \grp{} (\GRP) showing to be effective to solve these kinds of problems.

%An exploitation-oriented \commstr{} (in which the current configuration is communicated to focus various solvers in a more promising area) was successfully applied to the \sgp{}. The same idea was applied to solve the \nqp{}, showing no better results than without communication. However, a deep study of the \posl's behavior during the search process allows to design a \commstr{} able to improve the results of non-communicating strategies. It was based on crating \textit{companion} solvers (solvers only searching into a portion of the search space) to accelerate other's solvers search by communicating the current configuration. The cyclical exchange of this information shows good results for small instances. The \carrp{} is a very complicated constrained problem, and very sensitive to the methods to solve it. Thanks to some studies of different communication strategies, using the communication of the current configuration at different times (places) in the algorithm, it was possible to find a \commstr{} improving the performance obtained without communication. Finally, the \grp{} was chosen to study a different and innovative \commstr, in which the communicated information is a potential local minimum to be avoided. This new \commstr{} showed to be effective to solve these kinds of problems.

All these different \commstrs{} were tested easily thanks to the operator-based language provided by \posl{}. The process of building solvers implementing different solution strategies is complex and tedious, but \posl{} gives the possibility to make communicating and non-communicating solver prototypes and to study them with few efforts. It was possible to show that a good selection and management of inter-solvers communication can play an important role during the search process, for (most of them) very complicated constraint problems.

\section{Future works}

\posl{} is a tool entirely developed within the context of this thesis. It was completely new and remains under optimization. The first results using this language to solve \CSPs{} have been presented, but we believe that there is still a long way to go. 

One of the first steps to do when solving \csps{} using \posl{} is precisely the modeling problem. \posl{} (at the language level) does not provide a mechanism for benchmark modeling. It currently handles this issue through the low-level framework in C++, but the creation or integration of problem definition languages (\ie modeler) is one of the next goals. Another idea is to provide an interpreter for well known formats like {\sc MiniZinc} and/or \textit{XCSP}.

%The \comstr{} applied to the resolution of \nqp{}, where \textit{partial solvers} transmit the configuration to \textit{full solvers}, accelerates the search process at the beginning. However, once the a configuration is accepted by a \textit{full solver}, \textit{partial solvers} are no longer able to find better configurations to be sent. The first idea coming into our minds is to create \textit{cyclic} \comstrs{} in which \textit{full solvers} return their improved configurations to \textit{partial solvers}. This way the search process can be accelerated at various moments. 

\posl{} already has an important library of ready--to--use computation and connection modules, based on a deep study of classical meta-heuristics algorithms for solving combinatorial problems. In the near future we plan to make it grow in order to multiply possibilities with \posl{}. This way, building new algorithms with \posl{} will be easier. At the same time we plan to enrich the language by proposing new operators. It is necessary, to improve the solver definition language, allowing to build sets of many new solvers faster and easier. \new{For example, through regular expressions it would be possible to create arrays of solvers, instead of declaring them one by one.}

%The proposed \comstr{} combining intensification and exploration have showed good results. In that direction, many other strategies can be analyzed. For instance, the study of the cost history during the search process, in order to find a lower bound for the cost, that indicates when communicating the current configuration to all solvers. This strategy allows to focus the search in the same area by launching a generalized intensification.

Another \commstr{} we think to be successful is the following: \sosets{} containing very different solvers, working on different configurations passed from one solver to another. This way, the general algorithm follows various search trajectories in which all solvers take part.

When we work with \commstrs{} using \textit{tabu lists}, one of the most costly process is to find the right {\it parameters} for deciding the inclusion of \textit{tabu} members. A set of values showing the best behavior for each parameter was proposed after a tuning process of the local minima avoidance \commstr{} applied to \grp. Nevertheless, it is clear that in this part there is a lot of room for improvement. The key of the good performance of this strategy is the right election of the proximity criterion between configurations. For that reason this issue deserves a deep study in the future.

Furthermore, we aim to expand the communication definition language in order to create versatile, more complex and dynamic communication strategies, and to allow dynamic communication strategies changing during runtime. We also aim to improve \posl{} with more expressive operators in terms of communication between solvers. %Our goal is to allow dynamic modifications of communication strategies, \ie that such strategies can be adapted during runtime. 
This way many different communication strategies would be defined in the same \soset. As an example consider  different connection topologies having been defined in the same \commstr. We aim to perform some evaluation of the search process, in order to turn the \commstr{} into one which implements the connection topology with the best results. Furthermore, another perspective is to incorporate tools to easily achieve a balance between computation and communication. For this, an appropriate measure of the contribution of communication must be found.

%Then, after some time of calculation, an evaluation would be performed in order to make all solvers able to adopt the best strategy until the end of the search process.

In most of the performed experiments, the shared information was the best found configuration. So far, there are no results showing what ``a good information to communicate'' is. Actually, \cite{Caniou14} shows that in fact, the current configuration is not always a relevant information to share among solvers. That is why this subject deserves a deep study. We plan in the near future to investigate other information to be communicated, such as search directions, and search space features, among others.

\posl{} provides a mechanism of sharing not only data (\ie configurations, neighborhoods, etc.) but also \oms{}. This is the most interesting characteristic of \posl{} but it was not possible to analyze it properly. With data exchange, solvers can expand or change their search zones. However, by sharing \ms{}, they can also change and adapt their behavior. %In that sense, a future direction of this thesis proposes the study of other benchmark in order to find the right problem to successfully apply this approach.