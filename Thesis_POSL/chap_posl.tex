%----------------------------------------------------------------------------------------------
%------ POSL
%----------------------------------------------------------------------------------------------
\chapter{A Parallel-Oriented Language for Modeling Meta-Heuristic-Based Solvers}
\label{chap:posl}
\textit{In this chapter \posl{} is introduced as the main contribution, and a new way to solve \csps{}. Its characteristics and advantages are summarized, and a general procedure to be followed is described, in order to build parallel solvers using \posl, followed by a detailed description of each of the single steps.}
\vfill
\minitoc
\newpage

In this chapter we present the different steps to build communicating parallel solvers with \posl. 
First of all, the algorithm we have conceived to solve the target problem is decomposed it into small modules of computation, which are implemented as separated {\it functions}. We name them \oms{} (see Figure~\ref{subfig:modules}, blue shapes). At this point it is crucial to find a good decomposition of its algorithm, because it will have a significant impact in its future re-usage  and variability. The next step is to decide which information is interesting to \textit{receive} from other solvers. This information is encapsulated into another kind of component called \opch, allowing data transmission between solvers (see Figure~\ref{subfig:modules}, red shapes).
A third stage is to ensemble the modules through \posl{}'s inner language (the interested reader is referred to  Appendix~\tet{[...]}) to create independent solvers.
The parallel-oriented language based on operators provided by \posl{} (see Figure~\ref{subfig:as}, green shapes) allows not only the information exchange, but also executing components in parallel. In this stage the information that is interesting to be shared with other solvers is sent using operators. After that we can connect them using {\it communication operators}. We call this final entity a {\it solvers set} (see Figure~\ref{subfig:conn}).

\begin{figure}[h]
	\centering
	\subfloat[][Creating \posl's modules]{
		\label{subfig:modules}
		\includegraphics[width=0.4\linewidth]{modules.png}
	}\\
	\subfloat[][Assembling modules using \posl's operators]{%
		\label{subfig:as}
		\includegraphics[width=0.6\linewidth]{send_recv.png}
	}\\
	\subfloat[][Connecting \posl{} solvers to create \comstrs]{%
		\label{subfig:conn}
		\includegraphics[width=0.6\linewidth]{conn.png}
	}
	\caption[]{Solver construction process using \posl}
	\label{fig:posl}
\end{figure}

%Once the solvers set is ready, the last step is to model the problem to solve. To do so, the user must follow the framework specification to implement the benchmark, respecting some requirements. The most important one is to implement a {\it cost function} computing the cost for a given configuration, i.e., an integer indicating how much the configuration violates the set of constraints. This integer equals zero if the configuration is a solution.

In the following sections all these steps are explained in details, but first, I explain how to model the target benchmark using \posl.

\section{Modeling the target benchmark}
\label{sec:model}

\input{sect_model}

\section{First stage: creating \posl's modules}
\label{sec:1ststage}

\input{sect_1}

\section{Second stage: assembling \posl's modules}
\label{sec:2ndstage}

\input{sect_2}

\section{Third stage: creating \posl{} solvers}
\label{sec:3rdstage}

\input{sect_3}

\section{Forth stage: connecting the solvers}
\label{sec:4thstage}

\input{sect_4}

\section{Summarize}
\label{sec:posl_zum}

In this Chapter \posl{} have been formally presented, as a Parallel--Oriented Solver Language to build meta-heuristic-based solver to solve \CSPs{}. This language provides a set of \oms{} useful to solve a wide range of problems. It is also possible to create new ones if needed, using a low-level framework in C++ programming language. \posl{} also provides a set of \opchs{}, essential features to share information between solvers.

One of the advantages of \posl{} is to create \ass{} using a operator-based language, that remains independent of the used \bothmodules{}. That is why it is possible to create many different solvers using the same solution strategy (the \as) only instantiating it with different modules (\bothmodules). It is also possible to create different communication strategies using the {\it connection operators} that \posl{} provides.

In the next Chapter, a detailed study of various communicating and non-communicating strategies, using some \CSPs{} as benchmarks. In this study, the efficacy of \posl{} to study easily and fast these strategies, is showed.