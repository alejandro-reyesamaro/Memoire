%----------------------------------------------------------------------------------------------
%------ POSL
%----------------------------------------------------------------------------------------------
\chapter{A Parallel-Oriented Language for Modeling Constraint-Based Solvers}
\label{chap:posl}
\textit{In this chapter we introduce \posl{} as our main contribution and a new way to solve \csps{}. We resume its characteristics and advantages, and we get into details in the next sections. We describe a general outline to follow in order to build parallel solvers using \posl, and following each step is described in details.}
\vfill
\minitoc
\newpage

In this chapter we present the different steps to follow to build communicating parallel solvers with \posl. 
First of all, the algorithm that we have conceived to solve the target problem is modeled by decomposing it into small modules of computation. After that, they are implemented as separated {\it functions}. We name them \oms{} (see Figure~\ref{subfig:modules}, blue shapes). The coder's experience is crucial to find a good decomposition of its algorithm, because it will have an important impact in its future reuse and variability. The next step is to decide what information is interesting to receive from other solvers. This information is encapsulated into another kind of component called \opch, allowing data transmission among solvers (see Figure~\ref{subfig:modules}, red shapes).
In a third stage, is to glue the modules through \posl{}'s inner language (the reader can see an example in Appendix \tet{[...]}) to create independent solvers.
The parallel-oriented language based on operators that \posl{} provides (see Figure~\ref{subfig:as}, green shapes) allows not only the information exchange, but also executing components in parallel. In this stage, the information that is interesting to share with other solvers, is sent using operators. After that, we can connect them using {\it communication operators}. We call this final entity a {\it solvers set} (see Figure~\ref{subfig:conn}).

\begin{figure}[h]
	\centering
	\subfloat[][Creating \posl's modules]{
		\label{subfig:modules}
		\includegraphics[width=0.4\linewidth]{modules.png}
	}\\
	\subfloat[][Assembling modules using \posl's operators]{%
		\label{subfig:as}
		\includegraphics[width=0.6\linewidth]{as.png}
	}\\
	\subfloat[][Connecting \posl{} solvers to create \comstrs]{%
		\label{subfig:conn}
		\includegraphics[width=0.6\linewidth]{conn.png}
	}
	\caption[]{Solver construction process using \posl}
	\label{fig:posl}
\end{figure}

Once the solvers set is ready, the last step is to model the problem to solve. To do so, the user must follow the framework specification to implement the benchmark, respecting some requirements. The most important one is to implement a {\it cost function} computing the cost for a given configuration, i.e., an integer indicating how much the configuration violates the set of constraints. This integer equals zero if the configuration is a solution.

\section{First Stage: Creating \posl's modules}
\label{sec:1ststage}

\input{sect_1}

\section{Second Stage: Assembling \posl's modules}
\label{sec:2ndstage}

\input{sect_2}

\section{Third Stage: Creating \posl{} solvers}
\label{sec:3rdstage}

\input{sect_3}

\section{Forth Stage: Connecting the solvers}
\label{sec:4thstage}

We call \soset{} the pool of (concrete) solvers we plan to use in parallel to solve a problem. Once we have our solvers set, the last stage is to connect the solvers each others. Up to here, solvers are disconnected, but they have everything to establish the communication. \posl{} provides to the user a platform to easily define cooperative strategies that solvers must follow.

Following, we present two important concepts before we can formalize the {\it communication operators}.

\begin{definition}\label{def:comm_jack}
{\bf (Communication Jack)} Let a solver $\mathcal{S}$ be. Then, the operation $\mathcal{S}\cdot\mathcal{M}$ opens an outgoing connection from the solver $\mathcal{S}$ sending to the outside either 
\begin{inparaenum}[a)]
	\item the output of $\mathcal{M}$ if it is affected by a {\it sending data operator} presented in Definition~\ref{op:osend}, or
	\item $\mathcal{M}$ itself, if it is affected by a {\it sending module operator} presented in Definition~\ref{op:msend}.
\end{inparaenum}
\end{definition} 

\begin{definition}\label{def:comm_outlet}
{\bf (Communication Outlet)} Let a solver $\mathcal{S}$ be. Then, the operation $\mathcal{S}\cdot\mathcal{CM}$ opens an ingoing connection to the solver $\mathcal{S}$ receiving from the outside either 
\begin{inparaenum}[a)]
	\item the output of some \om{} if $\mathcal{CM}$ is a {\it data} \opch{}, or
	\item a \om{} if $\mathcal{CM}$ is an {\it object} \opch.
\end{inparaenum}
\end{definition} 


The communication is established by following the next rules guideline:
\begin{enumerate}%\begin{inparaenum}
	\item Each time a solver sends any kind of information by using a {\it sending} operator, it creates a \jack.
	\item Each time a solver defines a \opch, it creates a \outlet. 
	\item Solvers can be connected each others by linking \jacks{} to \outlets.
\end{enumerate} %\end{inparaenum}

%With the operator $(\cdot)$ we can have access to \oms{} sending information and to the \opch's names in a solver. 
%For example: $Solver_0\cdot \mathcal{M}$ provides access to the \om{} $\mathcal{M}$ in $Solver_0$ if and only if it is affected by a {\it sending} operator, and $Solver_1\cdot CM$ provides access to the \opch{} $CM$ in $Solver_1$.

Following, we define the \textit{connection operators} that \posl{} provides.

\begin{definition}\label{op_conn:1to1}
{\bf (Connection Operator One-to-One)} Let 
\begin{enumerate}
\item the list $\mathcal{J} = \left[\mathcal{S}_0\cdot \mathcal{M}_0, \mathcal{S}_1\cdot \mathcal{M}_1, ..., \mathcal{S}_{N-1}\cdot \mathcal{M}_{N-1}\right]$ of \jacks, and
\item the list $\mathcal{O} = \left[\mathcal{Z}_0\cdot \mathcal{CM}_0, \mathcal{Z}_1\cdot \mathcal{CM}_1, ..., \mathcal{Z}_{N-1}\cdot \mathcal{CM}_{N-1}\right]$ of \outlets{}
\end{enumerate} be. Then, the operation 
\[
\mathcal{J} \poslop{\rightarrow} \mathcal{O}
\]
Connects each \jack{} $\mathcal{S}_i\cdot \mathcal{M}_i \in \mathcal{J}$ with the corresponding \outlet{} $\mathcal{Z}_i\cdot \mathcal{CM}_i \in \mathcal{O}$, $\forall 0 \leq i \leq N-1$.
\end{definition}

\begin{definition}\label{op_conn:1ton}
{\bf (Connection Operator One-to-N)} Let 
\begin{enumerate} 
\item the list $\mathcal{J} = \left[\mathcal{S}_0\cdot \mathcal{M}_0, \mathcal{S}_1\cdot \mathcal{M}_1, ..., \mathcal{S}_{N-1}\cdot \mathcal{M}_{N-1}\right]$ of \jacks, and 
\item the list $\mathcal{O} = \left[\mathcal{Z}_0\cdot \mathcal{CM}_0, \mathcal{Z}_1\cdot \mathcal{CM}_1, ..., \mathcal{Z}_{M-1}\cdot \mathcal{CM}_{M-1}\right]$ of \outlets{} 
\end{enumerate} be. Then, the operation 
\[
\mathcal{J} \poslop{\rightsquigarrow} \mathcal{O}
\]
Connects each \jack{} $\mathcal{S}_i\cdot \mathcal{M}_i \in \mathcal{J}$ with every \outlet{} $\mathcal{Z}_j\cdot \mathcal{CM}_j \in \mathcal{O}$, $\forall 0 \leq i \leq N-1$ and $0 \leq j \leq M-1$.
\end{definition}

\begin{definition}\label{op_conn:ring}
{\bf (Connection Operator Ring)} Let 
\begin{enumerate} 
\item the list $\mathcal{J} = \left[\mathcal{S}_0\cdot \mathcal{M}_0, \mathcal{S}_1\cdot \mathcal{M}_1, ..., \mathcal{S}_{N-1}\cdot \mathcal{M}_{N-1}\right]$ of \jacks, and 
\item the list $\mathcal{O} = \left[\mathcal{S}_0\cdot \mathcal{CM}_0, \mathcal{S}_1\cdot \mathcal{CM}_1, ..., \mathcal{S}_{N-1}\cdot \mathcal{CM}_{N-1}\right]$ of \outlets{} 
\end{enumerate} be. Then, the operation 
\[
\mathcal{J} \poslop{\leftrightarrow} \mathcal{O}
\]
Connects each \jack{} $\mathcal{S}_i\cdot \mathcal{M}_i \in \mathcal{J}$ with the corresponding \outlet{} $\mathcal{Z}_{(i+1)\%N}\cdot \mathcal{CM}_{(i+1)\%N} \in \mathcal{O}$, $\forall 0 \leq i \leq N-1$.
\end{definition}

%\begin{figure}
%\centering
%\subfloat[][1 to 1]{
%	\label{subfig:comm_simple}
%	\includegraphics[width=0.12\textwidth]{1-1_v2} %[width=0.2\textwidth]{muta1}
%}
%\hspace{0.05\textwidth}%
%\subfloat[][1 to N]{%
%	\label{subfig:comm_diff}
%	\includegraphics[width=0.12\textwidth]{1-n_v2}%[width=0.2\textwidth]{muta2}
%}
%\caption[]{Communication operators}
%\label{fig:comm}
%\end{figure}

%These connections \begin{inparaenum}[1.]
%	\item assign an available unit of computation (typically a thread) to each solver, and
%	\item connect solvers each other.
%\end{inparaenum}


%We can divide solvers into two groups: solvers sending information to other solvers, named {\it sender solvers}, and solvers receiving information from others, named {\it receiver solvers}. A same solver can belongs to both groups, however in experiments exposed in this paper, we only build communicating solvers belonging exclusively to one group or the other.  

%We can also schedule non-communicating solvers:
%\[
%\left[\Sigma_0\cdot M_0, \Sigma_1\cdot M_1, ..., \Sigma_{N-1}\cdot M_{N-1}\right]
%\]

\section{Fifth Stage: Modeling the target benchmark}

In this stage we explain formally our modeling process of a benchmark to be solved (or study) through \posl{}. We explain how to make use of the already existing models or to create new benchmarks using the basic layer of the framework in C++ making a proper usage of the object-oriented design.

\section{Step-by-step \posl{} code example}

In this section we summarize all the steps to build a \posl{} meta--solver through an real example, providing schemes to make more comprehensive the process.
