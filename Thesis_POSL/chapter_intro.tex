\chapter{Introduction}
\label{chap:Intro}
\textit{The \textit{Introduction} of the work is presented. We describe the target problem (the formal definition will be in the next chapter), and the approaches implemented so far to solve them. The necessity of a new approach to exploit the new era of parallelism is introduced.
In this section are presented the goals of the thesis, and \posl{} is introduced as a new parallel approach including others and novel features. Finally, we describe the structure of the document.}
\vfill
\minitoc
\newpage

Combinatorial Optimization has several applications in fields like machine learning, artificial intelligence, and software engineering. In some cases, the main goal is only to find a solution, like for {\it Constraint Satisfaction Problems (CSP)}. A solution will be an assignment of variables satisfying the constraint set. A CSP is defined by a triple $\langle X,D,C \rangle$ where $X=\{x_1, x_2,\dots,x_n\}$ is a finite set of variables, $D = \{D_1, D_2,\dots, D_n\}$ is the set of domains associated to each variable in $X$, and $C = \{c_1, c_2,\dots,c_m\}$ is a set of constraints. Each constraint is defined over a set of variables, and specifies the possible combinations of values for these variables. A configuration $s\in D_1\times D_2\times\dots\times D_n$ is a combination of values for the variables of $X$. We say that $s$ is a solution of a {\it CSP} if and only if $s$ satisfies all constraints $c_i \in C$.

There exist many different techniques to solve such problems, mainly classified into two categories: tree-search based algorithms exploring the full search space and meta-heuristics applying some stochastic moves. Although many of these techniques have been shown to be effective, sometimes the search space of problems we want to solve is huge, and in most cases it makes the problem intractable, in particular for tree-search based algorithms. However, the development of computer architecture is leading us toward massively multi/many--core computers. These architectures unlock new algorithmic possibilities to tackle problems sequential algorithms cannot handle.

As result of such developments, parallel algorithms have opened new ways to solve constraint problems. Adaptive Search~\cite{Diaz} is an efficient method reaching linear speed-ups on hundreds and even thousands of cores (depending of the problem), using an independent multi-walk local search parallel scheme. Munera et al~\cite{Munera} present another implementation of Adaptive Search using communication between search engines, showing the efficiency of cooperative multi-walks strategies. {\it Meta--S} is an implementation of a theoretical framework proposed in~\cite{Frank2003}, which allows to tackle problems, through the cooperation of arbitrary domain--specific constraint solvers. All these results use a multi-walk parallel approach and show the robustness and efficiency of this parallel scheme. Although, they all concluded there is room for improvements. 

It is well-known software programming is a very time-consuming activity. This is even more the case while developing a parallel software, where debugging is an extremely difficult task. \posl{}'s main goal is to propose to CSP solver designers/programmers a parallel framework to quickly build parallel prototypes, speeding-up the design process. 

In this thesis we present \posl, a framework for easily building many and different cooperating solvers based on coupling four fundamental and independent components: \oms, \opchs, the \ass{} and \comstrs. Recently, the hybridization approach leads to very good results in constraint satisfaction. For that reason, since the solver's component can be combined, our framework is designed to execute in parallel sets of different solvers, with and without communication.

\posl{} provides, through a simple operator-based language, a way to create \ass, combining already defined \ms{} (\oms{} and \opchs). A similar idea was proposed in \cite{Fukunaga2008} without communication, introducing an evolutionary approach that uses a simple composition operator to automatically discover new local search heuristics for SAT and to  visualize them as combinations of a set of building blocks. 
In the last phase of the coding process with \posl{}, solvers can be connected each others, depending on the structure of their \opch s, and this way, they can share not only information, but also their behavior, by sharing their \oms. This approach makes the solvers able to evolve during the execution.