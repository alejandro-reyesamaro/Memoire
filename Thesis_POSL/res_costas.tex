\modified{In this section I present the performed study using \carrp{} (\CARRP) as a benchmark.}

\subsection{Problem definition}

The \carrp{} (\CARRP) consists in finding a \textit{costas array}, which is an $n\times n$ grid containing $n$ marks such that there is exactly one mark per row and per column and the $n(n-1)/2$ vectors joining each couple of marks are all different. This is a very complex problem that finds useful application in some fields like sonar and radar engineering. It also presents an interesting characteristic: although the search space grows factorially, from order 17 the number of solutions drastically decreases~\cite{Drakakis2006}.

\modified{The cost function for this benchmark was implemented in C++ based on the current implementation of {\it Adaptive Search}\footnote{It is based on the code from Daniel D\'{i}az available at \href{https://sourceforge.net/projects/adaptivesearch/}{https://sourceforge.net/projects/adaptivesearch/}}.}

\subsection{Experiment design}

To handle this problem, I have reused all modules used for solving the \nqp.
%\begin{enumerate}
%	\item Generation module:
%	\subitem $I$: Generates a random configuration $s$, as a permutation of the vector $[1..n]$. 
%	\item Neighborhood module:
%	\subitem $V_{AS}$: Defines the neighborhood $V\left(s\right)$ swapping the variable which contributes the most to the cost with other.
%\end{enumerate}
\modified{First attempts to solve this problems were using the same strategies (\ass) used to solve the \sgp{} and \nqp, without success: \posl{} was not able to solve instances larger than $n = 8$ in a reasonable amount of time (seconds). After many unsuccessful attempts to find the rights parameter of \textit{maximum number of restarts}, \textit{maximum number of iterations}, and \textit{maximum number of iterations with the same cost}, I decided to implement the mechanism used by Daniel D\'iaz in the current implementation of {\it Adaptive Search} to escape from local minima: } I have added a {\it Reset} module ($R$).

The basic solver I use to solve this problem is presented in Algorithm~\ref{as:costas}, and I take it as a base to build all the different communication strategies. \modified{Basically, it is a classical local search iteration, where instead of performing restarts, it performs resets. After a deep analysis of this implementation and results of some runs, I decided to use $K_1 = 24000$ (maximum number of iterations) big enough to solve the chosen instance $n = 17$; and $K_2 = 3$ (the number of iteration before performing the next \textit{reset}).} 

\begin{algorithm}[H]
\dontprintsemicolon
\SetNoline
\SetKwProg{myproc}{\tet{\bf abstract solver}}{\tet{\bf begin}}{\tet{\bf end}}
\myproc{as\_hard \tcp*{{\sc Itr} $\rightarrow$ number of iterations}
	\tet{\bf computation} : $I, R, V, S, A$\;}{ %\tcp*{{\sc Sci} $\rightarrow$ number of iterations with the same cost}}{%
	$I \poslop{\mapsto}$\\
	\While{$\left(\textbf{\Iter < } K_1\right)$}{
		$R \poslop{\mapsto}$ % \left[\circlearrowleft (\text{\Iter}\% K_2) \left\{ M_V \longmapsto M_{\hat{S}} \longmapsto M_D\right\}\right]$\;
		\whileinline{$\left(\textbf{\Iter \% } K_2\right)$}{$\left[V \poslop{\mapsto} S \poslop{\mapsto} A\right]$}
	}
}
\caption{Reset-based \as{} for \CARRP}\label{as:costas}
\end{algorithm}

The \as{} for the sender solver is presented in Algorithm~\ref{as:costas_sender}. Like for the \sgp, we design different communication strategies combining different percentages of communicating solvers and our two communication operators ({\it 1~to~1} and {\it 1~to~N}). However for this problem, we study the behavior of the communication performed at two different moments: while applying the acceptance criteria (Algorithm~\ref{as:costas_receiver_a}), and while performing a {\it reset} (Algorithms~\ref{as:costas_receiver_a},~\ref{as:costas_receiver_b}~and~\ref{as:costas_receiver_c}).

\begin{algorithm}[H]
\dontprintsemicolon
\SetNoline
\SetKwProg{myproc}{\tet{\bf abstract solver}}{\tet{\bf begin}}{\tet{\bf end}}
\myproc{as\_hard\_sender \tcp*{{\sc Itr} $\rightarrow$ number of iterations}
	\tet{\bf computation} : $I, R, V, S, A$\;}{ %\tcp*{{\sc Sci} $\rightarrow$ number of iterations with the same cost}}{%
	$I \poslop{\mapsto}$\\
	\While{$\left(\textbf{\Iter < } K_1\right)$}{
		$R \poslop{\mapsto}$ 
		\whileinline{$\left(\textbf{\Iter \% } K_2\right)$}{$\left[V \poslop{\mapsto} S \poslop{\mapsto} \llparenthesis A \rrparenthesis^o \right]$}
	}
}
\caption{Reset-based \as{} for \CARRP{} (sender)}\label{as:costas_sender}
\end{algorithm}

\begin{algorithm}[H]
\dontprintsemicolon
\SetNoline
\SetKwProg{myproc}{\tet{\bf abstract solver}}{\tet{\bf begin}}{\tet{\bf end}}
\myproc{as\_hard\_receiver\_a \tcp*{{\sc Itr} $\rightarrow$ number of iterations}
	\tet{\bf computation} : $I, R, V, S, A$\; %\tcp*{{\sc Sci} $\rightarrow$ number of iterations with the same cost}
	\tet{\bf communication} : $C.M.$\;}{%
	$I \poslop{\mapsto}$\\
	\While{$\left(\textbf{\Iter < } K_1\right)$}{
		$R \poslop{\mapsto}$
		\whileinline{$\left(\textbf{\Iter \% } K_2\right)$}{$\left[V \poslop{\mapsto} S \poslop{\mapsto} \left[A \poslop{m} C.M.\right]\right]$}
	}
}
\caption{Reset-based \as{} for \CARRP{} (receiver, variant A)}\label{as:costas_receiver_a}
\end{algorithm}

\begin{algorithm}[H]
\dontprintsemicolon
\SetNoline
\SetKwProg{myproc}{\tet{\bf abstract solver}}{\tet{\bf begin}}{\tet{\bf end}}
\myproc{as\_hard\_receiver\_b \tcp*{{\sc Itr} $\rightarrow$ number of iterations}
	\tet{\bf computation} : $I, R, V, S, A$\tcp*{{\sc Sci} $\rightarrow$ number of iterations with the same cost}
	\tet{\bf communication} : $C.M.$\;}{%
	$I \poslop{\mapsto}$\\
	\While{$\left(\textbf{\Iter < } K_1\right)$}{
		$\left[R \poslopcond{\Sci < K_3} \left[R \poslop{m} C.M.\right]\right] \poslop{\mapsto}$
		\whileinline{$\left(\textbf{\Iter \% } K_2\right)$}{$\left[V \poslop{\mapsto} S \poslop{\mapsto} A\right]$}
	}
}
\caption{Reset-based \as{} for \CARRP{} (receiver, variant B)}\label{as:costas_receiver_b}
\end{algorithm}

\begin{algorithm}[H]
\dontprintsemicolon
\SetNoline
\SetKwProg{myproc}{\tet{\bf abstract solver}}{\tet{\bf begin}}{\tet{\bf end}}
\myproc{as\_hard\_receiver\_c \tcp*{{\sc Itr} $\rightarrow$ number of iterations}
	\tet{\bf computation} : $I, R, V, S, A$\; %\tcp*{{\sc Sci} $\rightarrow$ number of iterations with the same cost}
	\tet{\bf communication} : $C.M.$\;}{%
	$I \poslop{\mapsto}$\\
	\While{$\left(\textbf{\Iter < } K_1\right)$}{
		$\left[R \poslop{m} C.M.\right] \poslop{\mapsto}$
		\whileinline{$\left(\textbf{\Iter \% } K_2\right)$}{$\left[V \poslop{\mapsto} S \poslop{\mapsto} A\right]$}
	}
}
\caption{Reset-based \as{} for \CARRP{} (receiver, variant C)}\label{as:costas_receiver_c}
\end{algorithm}

\subsection{Analysis of results}

\modified{I present in Table~\ref{tab:costas17} results of launching {\it solver sets} to solve each instance of \carrp{} sequentially. Runtimes and iteration means showed in this table are bigger than those presented in Table~\ref{tab:costas17comm}, confirming once again the success of the parallel approach.} %The column labeled \textbf{\% success} indicates the percentage of solvers that were able to find a solution before a time--out (5 minutes).

\begin{table}[h]
\captionsetup{belowskip=6pt,aboveskip=6pt}
\centering
\renewcommand{\arraystretch}{1}
\begin{tabular}{p{3.5cm}|R{1cm}R{1cm}R{1.2cm}R{1.2cm}R{2cm}}
	\hline
	{\bf STRATEGY} & T & T(ds) & It. & It.(sd) & \% success\\
	\hline
	%\hline
	Sequential (1 core) & 2.12 & 0.87 & 44,453 & 18,113 & 42.00\\
	Parallel (40 cores) & 0.73 & 0.46 & 9,556 & 6,439 & 100.00\\
	\hline
\end{tabular}
\caption{\carr{} 17: no communication}
\label{tab:costas17}
\end{table}

\modified{I chose directly the neighborhood module ($V_{AS}$), the selection module ($S_{First}$) and the acceptance module $A$, to create solvers. I ran experiments to study parallel communicating strategies taken into account the structure of the communication, and the communication operator used, but in this problem, I perform the communication at two different times: at the time of applying the acceptance criteria, and at the time of performing the {\it reset}.}

\begin{table}
\centering 
\renewcommand{\arraystretch}{1}
\begin{tabular}{p{2.5cm}|R{1cm}R{1cm}R{1cm}R{1.2cm}|R{1cm}R{1cm}R{1cm}R{1.2cm}}
	\hline
	\multirow{3}{*}{\footnotesize{\centering {\bf STRATEGY}}} & \multicolumn{4}{c}{100\% COMM} & \multicolumn{4}{c}{50\% COMM} \\
	\cline{2-9}
	& T & T(sd) & It. & It.(sd) & T & T(sd) & It. & It.(sd)\\
	\hline
	Str A: 1 to 1 & \good{0.41} & 0.30 & 4,973 & 3,763 & 0.55 & 0.43 & 8,179 & 7,479\\
	Str A: 1 to N & 0.43 & 0.31 & 5,697 & 4,557 & 0.57 & 0.46 & 8,420 & 7,564\\	
	Str B: 1 to 1 & 0.48 & 0.41 & 6,546 & 5,562 & 0.51 & 0.49 & 8,004 & 7,998\\
	Str B: 1 to N & 0.45 & 0.46 & 5,701 & 6,295 & 0.48 & 0.51 & 7,245 & 8,379\\
	Str C: 1 to 1 & 0.48 & 0.43 & 6,954 & 6,706 & 0.58 & 0.43 & 8,329 & 6,593\\
	Str C: 1 to N & 0.49 & 0.38 & 6,457 & 5,875 & 0.58 & 0.50 & 8,077 & 8,319\\
	\hline
\end{tabular}
\caption{\carr{} 17: with communication}
\label{tab:costas17comm}
\end{table}

\modified{Table~\ref{tab:costas17comm} shows that the \as{} {\it A} (receiving the configuration at the time of applying the acceptance criteria) is more effective. The reason is that the others, interfere with the proper performance of the {\it reset}, that is a very important step in the algorithm. This step can be performed on three different ways:} 
\begin{enumerate}
\item Trying to shift left/right all sub-vectors starting or ending by the variable which contributes the most to the cost, and selecting the configuration with the lowest cost.
\item Trying to add a constant (circularly) to each element in the configuration.
\item Trying to shift left from the beginning to some culprit variable (i.e., a variable contributing to the cost).
\end{enumerate}
\modified{Then, one of these 3 generated configuration has the sabe probability of being selected, to be the result of the \textit{reset} step. In that sense, some different \textit{resets} can be performed for the same configuration. Here is when the communication play its important role: receiver and sender solvers apply different \textit{reset} in the same configuration, and results showed the efficacy of this communication strategy.}

Table~\ref{tab:costas17comm} shows also high values of standard deviation. This is not surprising, due to the highly random nature of the neighborhood function and the selecting criterion, as well as the execution of many resets during the search process.